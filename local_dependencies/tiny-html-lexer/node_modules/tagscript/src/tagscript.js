"use strict"
const utils = require ('./utils')
const log = console.log.bind (console)
module.exports =  { tag, start:tag, leaf, end, raw, comment, render, renderTo, flatten:utils.flatten, Renderer }

// Tag functions

function tag (name, atts=null) {
  return new StartTag (validateName (name), atts, false)
}

function leaf (name, atts=null) {
  return new StartTag (validateName (name), atts, true)
}

function end (name) {
  return new EndTag (validateName (name))
}

function raw (data) {
  return new Raw (data)
}

function comment (data) {
  return new Comment (data)
}

// function node (name, atts, children) {
//   return new Node (validateName (name), atts, children)
// }


// render functions

function render (obj) {
  let result = ''
  renderTo ({ write: chunk => { result += chunk } }, obj)
  return result
}

function renderTo (writable, obj) {
  return new Renderer (writable) .write (obj)
}

// Tag objects

class Tag {}

class StartTag extends Tag {
  constructor (name, attributes=null, autoclose=false) {
    super ()
    this.tagName = name
    this.attributes = attributes
    this.autoclose = !!autoclose
  }
  toString () {
    return `<${ this.tagName }${ renderAttributes (this.attributes) }${ this.autoclose ? '/' : '' }>`
  }
}


class EndTag extends Tag {
  constructor (name) {
    super ()
    this.tagName = name
  }
  toString () {
    return `</${ this.tagName }>`
  }
}


class Comment extends Tag {
  constructor (data) {
    super ()
    this.value = data
  }
  toString () {
    // TODO escape, or throw on invalid value ?
    return `<!--${ this.value }-->`
  }
}

function Raw (data) {
  this.data = data
}

// And, node trees
function Node (name, atts, children = []) {
  this.tagName = name
  this.attributes = atts
  this.children = children
}


// Renderer

const Symbols = new Proxy ({}, {get:(_,k) => Symbol (k) })
const { VOID, RAWTEXT, DATA, RCDATA, PLAINTEXT } = Symbols

const contentMap = { 
  style: RAWTEXT,
  script: RAWTEXT,
  xmp: RAWTEXT,
  iframe: RAWTEXT,
  noembed: RAWTEXT,
  noframes: RAWTEXT,
  textarea: RCDATA,
  title: RCDATA,
  // noscript: RAWTEXT // (if scripting is enabled, but I default to DATA)
  plaintext: PLAINTEXT
  // void tags; tags where <name/> is equivalent <name>
  // Note that for svg and mathML this is NOT the case, e.g. <path/> = <path></path>
  /*
  br: VOID
  hr: VOID
  img: VOID
  input: VOID
  link: VOID
  meta: VOID
  area: VOID
  base: VOID
  col: VOID
  command: VOID
  embed: VOID
  keygen: VOID
  param: VOID
  source: VOID
  track: VOID
  wbr: VOID
  */
}

// Tag objects 'inside' plaintext and rawtext elements are simply
// rendered as is. Tag objects within rcdata are rendered and escaped. 

function Renderer (out) {
  let state = DATA
  let tagName

  this.write = write
  this.writeRaw = function () { out.write.apply (out, arguments) }
  this.end = function () { return out.end () }

  function write (...obj) {
    let r
    for (let item of utils.flatten (obj)) {

      if (item instanceof Raw)
        out.write (item.data) // TODO: Q: should this be parsed for state-changes or not?

      else switch (state) {

        case RAWTEXT:
          if (item instanceof EndTag && item.tagName === tagName) {
            state = DATA
            r = out.write (renderTag (item))
          }
          else
            r = out.write (String (item)) // TODO: Q: shoud we throw on endTags within? or somehow escape?
        break

        case RCDATA:
          if (item instanceof EndTag && item.tagName === tagName) {
            state = DATA
            r = out.write (renderTag (item))
          }
          else
            r = out.write (String (item).replace (AMPLT, escapeChar))
        break

        case PLAINTEXT:
          r = out.write (String (item))
        break

        default:
          if (item instanceof StartTag) {
            tagName = item.tagName
            state = item.tagName in contentMap ? contentMap [tagName] : DATA
            r = out.write (renderTag (item))
          }
          else
            r = out.write (renderTag (item))
        break
      }
    }
    return r // for Node js style backpressure
  }
}


// Helper functions (private)

const TAGNAME = /^[a-zA-Z][^>/\t\n\f ]*$/
const ATTRNAME = /^[^\t\n\f />][^\t\n\f /=>]*$/
const AMPLT = /[&<]/g
const AMPQ = /[&"]/g

function renderTag (token) {
  return token instanceof Tag ? token.toString () : String (token) .replace (AMPLT, escapeChar)
}

function validateName (name) {
  if (! TAGNAME.test (name))
    throw Error ('tagscript: invalid tag name: ' + name)
  return name
}

function escapeName (name) {
  return name[0] === '=' ? '/'+name : name
}

function escapeChar (c) {
  return c === '&' ? '&amp;'
  : c === '<' ? '&lt;'
  : c === '"' ? '&quot;' : c }


// functions, null and undefined are ignored and likewise
// all attributes with a name that does not match `ATTRNAME` are ignored
// because they can not be escaped. Yet the ones that start with an = sign,
// do have to be 'escaped' by prefixing them with a /. 

// TODO, how exactly shall we handle null, undefined, true, false
//  and value-less attributes?

function renderAttributes (args) {
  const r = ['']
  for (let k in args)
    if (args[k] != null && typeof args[k] !== 'function' && ATTRNAME.test (k)) {
      let v = String (args[k])
      if (v === '') r.push (escapeName(k))
      else r.push ([escapeName(k), '="', String (v) .replace (AMPQ, escapeChar), '"'] .join (''))
    }
  return r.join (' ')
}



