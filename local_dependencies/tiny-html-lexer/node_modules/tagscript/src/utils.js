"use strict"
module.exports = { flatten }

function flatten (obj) {
  return new LazilyFlattened (arguments)
}

// Lazily flattened objects

function LazilyFlattened (obj) {
  this.object = obj
}

LazilyFlattened.prototype [Symbol.iterator] = function () {
  return new FlattenIterator (this.object)
}

// Flatten Iterator
// This uses a stack of 'markers', objects that keep track 
// how much of nested subobjects has been emitted yet. 

function FlattenIterator (obj) {
  const stack = [ marker (obj) ]

  this.next = function () {
    while (true) {
      const head = stack [stack.length - 1]
      
      if (head.done) {
        if (stack.length > 1) {
          stack.pop ()
          stack [stack.length - 1] .increment ()
        }
        else return { done: true }
      }

      else {
        const child = marker (head.child)
        if (child instanceof LeafMarker) {
          head.increment ()
          return { done: false, value: child.value }
        }
        else stack.push (child)
      }
    }
  }
}


function marker (obj) {
  return obj == null ? new LeafMarker (obj)
    : typeof obj === 'string' ? new LeafMarker (obj)
    : Array.isArray (obj) ? new ArrayMarker (obj)
    : typeof obj [Symbol.iterator] === 'function' ? new IteratorMarker (obj)
    : new LeafMarker (obj)
}


function LeafMarker (obj) {
  this.value = obj
}


// Array and Iterator 'Markers' are almost lateral iterators themselves. 
// Calling 'increment' moves their 'child selection' to the right by one position. 

function IteratorMarker (obj) {
  obj = obj [Symbol.iterator] ()
  this.increment = function () {
    let n = obj.next ()
    this.done = n.done
    this.child = n.value
    return this
  }
  this.increment ()
}

function ArrayMarker (obj) {
  let index = -1
  this.increment = function () { 
    index += 1
    this.done = index >= obj.length
    this.child = !this.done ? obj[index] : null
    return this
  }
  this.increment ()
}

